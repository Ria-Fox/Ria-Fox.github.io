<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        h3{
            margin-bottom: 5px;
        }
        h4, h5 {
            margin-bottom: 5px;
            margin-top: 5px;
        }
        pre {
            border-width: 1px;
            border-color: black;
            border-style: dashed
        }
    </style>
</head>
<body>
    <h1>SD 정리</h1>
    <br/>
    index<br/>
    <ul>
        <li>
            <a href="#Lecture1">Lecture 1</a> : Software Process
        </li>
        <li>
            <a href="#Lecture2">Lecture 2</a> : Software Configuration Management
        </li>
        <li>
            <a href="#Lecture3">Lecture 3</a> : Testing
        </li>
        <li>
            <a href="#Lecture4">Lecture 4</a> : Software Process
        </li>
        <li>
            <a href="#Lecture5">Lecture 5</a> : Software Process
        </li>
        <li>
            <a href="#Lecture6">Lecture 6</a> : Software Process
        </li>
    </ul>

    <b id="Lecture1">How to design</b> -> 제대로 동작/신뢰/유연/보안이 소프트웨어의 퀄리티를 결정<br/>
    <b>Design process 존재</b> -> constraints and costs<br/>
    <br/>
    프로그램과 소프트웨어는 다름/서로 다른 프로세스와 기술  <br/>

    <h2>SD의 정의</h2>
    <h3>IEEE 610</h3>
    <i>The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of Software.</i> <br/>
    소프트웨어의 개발/수행/유지보수에 있어서 구조적/훈련된/정량적 접근<br/>
    
    <h3>Bauer</h3>
    <i>The establishment and use of sound engineering principles in order to economically obtain software that is reliable and works efficiently on real machines.</i> <br/>
    실제 머신에서 신뢰할 수 있고 효율적으로 작동하는 소프트웨어를 얻기 위한 엔지니어링 원리<br/>

    <h3>Sommerville</h3>
    <i>An engineering discipline that is concerned with all aspects of software production</i>

    <h2>Software Varies</h2>
    <ul>
        <li>Size</li>
        <li>How humans interact with it</li>
        <li>Requirements stability</li>
        <li>Need for reliability</li>
        <li>Need for security</li>
        <li>Portability</li>
        <li>Cost</li>
    </ul>

    <h2>Software Process</h2>
    <h3>Pressman</h3>
    <i>A framework for the tasks that are required to build high-quality software</i>
    <br/>
    <h3>IEEE 1074</h3>
    <i>A set of activities performed towards a specific purpose</i>

    <h3>Sommerville</h3>
    <i>a structured set of activities required to develop a software system</i>
    <br/>
    
    <h2>Software design process</h2>
    <b>Requirement</b> : What software should do<br/>
    <b>Design</b> : How software should do<br/>
    <b>Implementation and Integration</b> : How modules work and are integrated<br/>
    <b>Maintenance</b> : Eveolve software<br/>
    
    <i>Waterfell / Incremental Development / Prototyping / Spiral</i>

    <h2 id="Lecture2">Software Configuration Management</h2>
    <h3>Definition</h3>
    소프트웨어 시스템의 개발 과정(Evolution)을 컨트롤하기 위한 방법, <b>큰 프로젝트일수록 중요</b>
    
    <h3>Four major aspects</h3>
    Version control, building, change management, releasing
    <br/><br/>
    
    
    <h3>Version Control System(VCS)</h3>
    여러 버전의 시스템 컨포넌트를 지속적으로 모니터링<br/>
    여러 다른 개발자와 같이 작업하기 위함<br/>
    Revert cahnges, go back in time to a specific version<br/>
    <h4>Codeline & Baseline</h4>
    Codeline : a sequence of versions of source code<br/>
    Baseline: a set of component versions that make up a system<br/>
    
    <h4>Check-in & Check-out</h4>
    VCS는 Remote server와 개발자의 Workspace로 구성<br/>
    Check-in : Workspace -> Server <br/>
    Check-out : Server -> Workspace
    
    <h2>Git: Open Source Distributed VCS</h2>
    <h3>Git Basics</h3>
    <h4>Adding a New File to Track</h4>
    Track a new file or stage a modified file : <i>git add [filename>]</i> <br/>
    Check the status of your (tracked) files : <i>git status </i>
    <h4>Commit/Push Local Changes</h4>
    Commit (tracked) local changes made to <b>your local repository</b> : <i>git commit -m '[a meaningful dscriptive message]'</i><br/>
    Push your commits to the remote repository : <i>git push origin [branch name]</i>
    <h4>Updating Other Local Copies</h4>
    Pull changes form the remote repository : <i>git pull origin master</i><br/>
    View the commit history : <i>git log</i>
    
    <h2>Version Control Workflow</h2>
    1. Repository contains complete history <br/>
    2. Pull latest version<br/>
    3. Work on the code<br/>
    4. Commit and then push, making a new version of the software<br/>
    
    <h3>Parallel Work</h3>
    Pull V23 -> <br/>
    A : change and push V24 <br/>
    B : change and push after V24 -> Merge! <br/>
    
    <h3>Golden Rule of VCS</h3>
    <h4>Commit (and push) frequently!</h4>
    break work into small steps (Chapter 6 -> 에러가 발생할 경우 커밋 주기가 짧을수록 찾기 쉬워짐) <br/>
    <h4>커밋 주기가 길어질 수록</h4> : 다른 개발자와 간섭이 많아지고 머지하기 힘듬 <br/>
    
    <h3>Branching</h3>
    <h4>Encourage branches</h4> : use of short-lived like <b>new functions, fixing bugs, experimental versions...</b><br/>
    support different hardware platform, different customer는 Long-lived 브랜치 -> 다른 프로젝트로 생성
    
    <h2>Build Management</h2>
    build procedure를 테스트하기 위해 정기적으로 빌드해 줘야 됨 -> Building should be automatic <br/>
    should minimize redundant recompilation<br/>
    
    <h3>Daily build and smoke testing</h3>
    <h4>Build process cna be broken</h4> : 잘못된 코드의 check-in, 빌드 스크립트에 파일 인클루드 안함, 라이브러리 이동 등 <br/>
    -> 매일 정해진 시간에 가장 최신 버전의 빌드를 찍어보고 간단한 테스트 돌려보기(Smoke testing)
    
    <h2>Change Management</h2>
    제품이 시간에 따라 어떻게 바뀌는지 계속 추적할 수 있어야 됨 -> 어느 버전이든지 생성할 수 있어야 됨<br/>
    필요한 변경이 이루어졌는지, 잘못된 변경점이 없는지 컨트롤할 수 있어야 됨 <br/>
    소스 뿐만 아니라 non-code 리소스 또한 관리 필요
    <h3>Change request</h3> : 변경을 누가, 왜, 언제 이루어졌는지 기록해야 됨 -> Issue tracking<br/>
    Change request의 예 : New feature or bug report <br/>
    change request와 code changes는 링크되어 있어야 됨
    <h3>Key Elements in Bug Reporting</h3>
    <ul>
        <li>
            <h4>Reproduce</h4> : test it again <br/>
            항상 failure를 재현할 수 있는지 확인해야 됨 (three time rule)<br/>
            failure를 재현하는 순서를 문서화<br/>
            <pre>                Good Steps to Reproduce
                1. I started the SpeedyWriter editor, then I
                created a new file
                2. I then typed in four lines of text,
                repeating “The quick fox jumps over
                the lazy brown dog” each time, using
                different effects each time, bold, italic,
                strikethrough, and underline.
                3. I highlighted the text, then pulled down
                the font menu, and selected Arial
                4. This nasty bug trashed all the text into
                meaningless garbage, wasting the user’s
                time.
                5. I was able to reproduce this problem
                three out of three tries.            </pre>
        </li>
        <li>
            <h4>Isolate</h4> : test it differently <br/>
            Failure를 좁히기 위해 관련되지 않은 요소 제거 : 문제를 재현하기 위한 가장 간단한 방법을 찾아야 됨 <br/>
            변수를 하나씩 바꿔보기 <br/>
            <pre>                Isolation example
                On the vague suspicion that this was just
                aformatting problem, I saved the file,
                closedSpeedyWriter and reopened the file.
                The garbage remained. If you save the file
                before Arializing the contents, the bug does
                not occur.The bug does not occur with
                existing files.This only happens under
                Windows 98            </pre>
        </li>
        <li>
            <h4>Generalize</h4> : test it elsewhere <br/>
            다른 방법으로도 테스트해봄으로서 동일 버그가 발생하는지 확인 <br/>
            The problem can be more general and require more general fix<br/>
            Generalized bug reports : reduces duplicate bug reports, refines understanding of failure
        </li>
    </ul>
    
    <h2>Release</h2>
    다른 사람에게 배포하기 위한 버전 : 반드시 baseline이어야 함
    
    <h2>Various tests</h2>
    Smoke test : change 이후에도 동작하는가? <br/>
    Unit test : change 이후에도 모듈이 고장나지 않았는가? <br/>
    Regression test : 기존 코드가 더 나빠지지 않았는가? <br/>
    
    <h2>Continuous Integration</h2>
    Building and testing software projects continuously <br/>
    Need <b>automated</b> building and testing
    
    <h2 id="Lecture3">Testing</h2>
    <h3>What is test?</h3> : 소프트웨어에 test input을 넣어 나온 output을 체크하는 과정<br/>
    테스트로 faults와 code를 기록할 수 있음
    <h3>Terminology</h3>
    <ul>
        <li>Test case : test inputs, values, data</li>
        <li>Test suite : a set of test cases</li>
        <li>Test oracle : mechanism for deciding if test has passed/failed</li>
    </ul>
    <h3>Why test?</h3>
    <b>Improve quailty</b> : find faults<br/>
    <b>Measure quality</b> : 실수가 있는가, 소프트웨어가 릴리즈될 수 있는가
    
    <h3>Mistake, Fault, Error, Failure</h3>
    programmer's mistake <br/>
    -> fault(defect, bug) appears in the program <br/>
    -> fault remains = program fails(based on test oracles)
    <br/><br/>
    fault : 코드 안의 오류<br/>
    error : observer 입장에서 발견한 fail<br/>
    fail : Test 도중 발견된 오류 <br/>
    
    <h3>Types of Testing : Code or functionality?</h3>
    <h4>Black Box Testing : Know the functionality</h4>
        
</body>
</html>