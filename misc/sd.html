<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        h3{
            margin-bottom: 5px;
        }
        h4, h5 {
            margin-bottom: 5px;
            margin-top: 5px;
        }
        pre {
            border-width: 1px;
            border-color: black;
            border-style: dashed
        }
    </style>
</head>
<body>
    <h1>SD 정리</h1>
    <br/>
    index<br/>
    <ul>
        <li>
            <a href="#Lecture1">Lecture 1</a> : Software Process
        </li>
        <li>
            <a href="#Lecture2">Lecture 2</a> : Software Configuration Management
        </li>
        <li>
            <a href="#Lecture3">Lecture 3</a> : Testing
        </li>
        <li>
            <a href="#Lecture4">Lecture 4</a> : Agile
        </li>
        <li>
            <a href="#Lecture5">Lecture 5</a> : Software Process
        </li>
        <li>
            <a href="#Lecture6">Lecture 6</a> : Software Process
        </li>
    </ul>

    <b id="Lecture1">How to design</b> -> 제대로 동작/신뢰/유연/보안이 소프트웨어의 퀄리티를 결정<br/>
    <b>Design process 존재</b> -> constraints and costs<br/>
    <br/>
    프로그램과 소프트웨어는 다름/서로 다른 프로세스와 기술  <br/>

    <h2>SD의 정의</h2>
    <h3>IEEE 610</h3>
    <i>The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of Software.</i> <br/>
    소프트웨어의 개발/수행/유지보수에 있어서 구조적/훈련된/정량적 접근<br/>
    
    <h3>Bauer</h3>
    <i>The establishment and use of sound engineering principles in order to economically obtain software that is reliable and works efficiently on real machines.</i> <br/>
    실제 머신에서 신뢰할 수 있고 효율적으로 작동하는 소프트웨어를 얻기 위한 엔지니어링 원리<br/>

    <h3>Sommerville</h3>
    <i>An engineering discipline that is concerned with all aspects of software production</i>

    <h2>Software Varies</h2>
    <ul>
        <li>Size</li>
        <li>How humans interact with it</li>
        <li>Requirements stability</li>
        <li>Need for reliability</li>
        <li>Need for security</li>
        <li>Portability</li>
        <li>Cost</li>
    </ul>

    <h2>Software Process</h2>
    <h3>Pressman</h3>
    <i>A framework for the tasks that are required to build high-quality software</i>
    <br/>
    <h3>IEEE 1074</h3>
    <i>A set of activities performed towards a specific purpose</i>

    <h3>Sommerville</h3>
    <i>a structured set of activities required to develop a software system</i>
    <br/>
    
    <h2>Software design process</h2>
    <b>Requirement</b> : What software should do<br/>
    <b>Design</b> : How software should do<br/>
    <b>Implementation and Integration</b> : How modules work and are integrated<br/>
    <b>Maintenance</b> : Eveolve software<br/>
    
    <i>Waterfell / Incremental Development / Prototyping / Spiral</i>

    <h2 id="Lecture2">Software Configuration Management</h2>
    <h3>Definition</h3>
    소프트웨어 시스템의 개발 과정(Evolution)을 컨트롤하기 위한 방법, <b>큰 프로젝트일수록 중요</b>
    
    <h3>Four major aspects</h3>
    Version control, building, change management, releasing
    <br/><br/>
    
    
    <h3>Version Control System(VCS)</h3>
    여러 버전의 시스템 컨포넌트를 지속적으로 모니터링<br/>
    여러 다른 개발자와 같이 작업하기 위함<br/>
    Revert cahnges, go back in time to a specific version<br/>
    <h4>Codeline & Baseline</h4>
    Codeline : a sequence of versions of source code<br/>
    Baseline: a set of component versions that make up a system<br/>
    
    <h4>Check-in & Check-out</h4>
    VCS는 Remote server와 개발자의 Workspace로 구성<br/>
    Check-in : Workspace -> Server <br/>
    Check-out : Server -> Workspace
    
    <h2>Git: Open Source Distributed VCS</h2>
    <h3>Git Basics</h3>
    <h4>Adding a New File to Track</h4>
    Track a new file or stage a modified file : <i>git add [filename>]</i> <br/>
    Check the status of your (tracked) files : <i>git status </i>
    <h4>Commit/Push Local Changes</h4>
    Commit (tracked) local changes made to <b>your local repository</b> : <i>git commit -m '[a meaningful dscriptive message]'</i><br/>
    Push your commits to the remote repository : <i>git push origin [branch name]</i>
    <h4>Updating Other Local Copies</h4>
    Pull changes form the remote repository : <i>git pull origin master</i><br/>
    View the commit history : <i>git log</i>
    
    <h2>Version Control Workflow</h2>
    1. Repository contains complete history <br/>
    2. Pull latest version<br/>
    3. Work on the code<br/>
    4. Commit and then push, making a new version of the software<br/>
    
    <h3>Parallel Work</h3>
    Pull V23 -> <br/>
    A : change and push V24 <br/>
    B : change and push after V24 -> Merge! <br/>
    
    <h3>Golden Rule of VCS</h3>
    <h4>Commit (and push) frequently!</h4>
    break work into small steps (Chapter 6 -> 에러가 발생할 경우 커밋 주기가 짧을수록 찾기 쉬워짐) <br/>
    <h4>커밋 주기가 길어질 수록</h4> : 다른 개발자와 간섭이 많아지고 머지하기 힘듬 <br/>
    
    <h3>Branching</h3>
    <h4>Encourage branches</h4> : use of short-lived like <b>new functions, fixing bugs, experimental versions...</b><br/>
    support different hardware platform, different customer는 Long-lived 브랜치 -> 다른 프로젝트로 생성
    
    <h2>Build Management</h2>
    build procedure를 테스트하기 위해 정기적으로 빌드해 줘야 됨 -> Building should be automatic <br/>
    should minimize redundant recompilation<br/>
    
    <h3>Daily build and smoke testing</h3>
    <h4>Build process cna be broken</h4> : 잘못된 코드의 check-in, 빌드 스크립트에 파일 인클루드 안함, 라이브러리 이동 등 <br/>
    -> 매일 정해진 시간에 가장 최신 버전의 빌드를 찍어보고 간단한 테스트 돌려보기(Smoke testing)
    
    <h2>Change Management</h2>
    제품이 시간에 따라 어떻게 바뀌는지 계속 추적할 수 있어야 됨 -> 어느 버전이든지 생성할 수 있어야 됨<br/>
    필요한 변경이 이루어졌는지, 잘못된 변경점이 없는지 컨트롤할 수 있어야 됨 <br/>
    소스 뿐만 아니라 non-code 리소스 또한 관리 필요
    <h3>Change request</h3> : 변경을 누가, 왜, 언제 이루어졌는지 기록해야 됨 -> Issue tracking<br/>
    Change request의 예 : New feature or bug report <br/>
    change request와 code changes는 링크되어 있어야 됨
    <h3>Key Elements in Bug Reporting</h3>
    <ul>
        <li>
            <h4>Reproduce</h4> : test it again <br/>
            항상 failure를 재현할 수 있는지 확인해야 됨 (three time rule)<br/>
            failure를 재현하는 순서를 문서화<br/>
            <pre>                Good Steps to Reproduce
                1. I started the SpeedyWriter editor, then I
                created a new file
                2. I then typed in four lines of text,
                repeating “The quick fox jumps over
                the lazy brown dog” each time, using
                different effects each time, bold, italic,
                strikethrough, and underline.
                3. I highlighted the text, then pulled down
                the font menu, and selected Arial
                4. This nasty bug trashed all the text into
                meaningless garbage, wasting the user’s
                time.
                5. I was able to reproduce this problem
                three out of three tries.            </pre>
        </li>
        <li>
            <h4>Isolate</h4> : test it differently <br/>
            Failure를 좁히기 위해 관련되지 않은 요소 제거 : 문제를 재현하기 위한 가장 간단한 방법을 찾아야 됨 <br/>
            변수를 하나씩 바꿔보기 <br/>
            <pre>                Isolation example
                On the vague suspicion that this was just
                aformatting problem, I saved the file,
                closedSpeedyWriter and reopened the file.
                The garbage remained. If you save the file
                before Arializing the contents, the bug does
                not occur.The bug does not occur with
                existing files.This only happens under
                Windows 98            </pre>
        </li>
        <li>
            <h4>Generalize</h4> : test it elsewhere <br/>
            다른 방법으로도 테스트해봄으로서 동일 버그가 발생하는지 확인 <br/>
            The problem can be more general and require more general fix<br/>
            Generalized bug reports : reduces duplicate bug reports, refines understanding of failure
        </li>
    </ul>
    
    <h2>Release</h2>
    다른 사람에게 배포하기 위한 버전 : 반드시 baseline이어야 함
    
    <h2>Various tests</h2>
    Smoke test : change 이후에도 동작하는가? <br/>
    Unit test : change 이후에도 모듈이 고장나지 않았는가? <br/>
    Regression test : 기존 코드가 더 나빠지지 않았는가? <br/>
    
    <h2>Continuous Integration</h2>
    Building and testing software projects continuously <br/>
    Need <b>automated</b> building and testing
    
    <h2 id="Lecture3">Testing</h2>
    <h3>What is test?</h3> : 소프트웨어에 test input을 넣어 나온 output을 체크하는 과정<br/>
    테스트로 faults와 code를 기록할 수 있음
    <h3>Terminology</h3>
    <ul>
        <li>Test case : test inputs, values, data</li>
        <li>Test suite : a set of test cases</li>
        <li>Test oracle : mechanism for deciding if test has passed/failed</li>
    </ul>
    <h3>Why test?</h3>
    <b>Improve quailty</b> : find faults<br/>
    <b>Measure quality</b> : 실수가 있는가, 소프트웨어가 릴리즈될 수 있는가
    
    <h3>Mistake, Fault, Error, Failure</h3>
    programmer's mistake <br/>
    -> fault(defect, bug) appears in the program <br/>
    -> fault remains = program fails(based on test oracles)
    <br/><br/>
    fault : 코드 안의 오류<br/>
    error : observer 입장에서 발견한 fail<br/>
    fail : Test 도중 발견된 오류 <br/>
    
    <h3>Types of Testing : Code or functionality?</h3>
    <h4>Black Box Testing : Know the functionality</h4>
    derive tests from external descriptions of the software<br/>
    소프트웨어 외부 행동을 관찰하여 기능과 인터페이스를 테스트 -> Requirements, specifications, design 등
    <h4>White Box Testing : Know the code</h4>
    소프트웨어의 코드레벨에서 테스트 : examination of procedural level in detail<br/>
    crashes, out of bounds, file not closed, uncaught exceptions
    
    <h3>Types of Testing : Top or Bottom?</h3>
    <h4>Top-Down Testing</h4> : Main precedure -> sub precedure
    <h4>Bottom-up Testing</h4> : smallest sub procedure -> upper procedure
    
    <h3>Types of Testing : Units, Modules, or System?</h3>
    <img src="image/sd1.PNG">
    <h4>Unit testing</h4> : test individual units, by programmers, white, bottom-up
    <h4>Integration testing </h4> : test interaction between components or units, by programmers, white (black for modules), bottom-up
    <h4>System testing</h4> : test complete system with respect to its requirements, by external test group, black, top-down
    <h4>Acceptance testing</h4> : satisfies acceptance criteria by customer, by customer, black, top-down
    <h3>Automated Testing : Trade-Off</h3>
    <b>Benefits</b> : regression testing의 cost 감소, 사람의 실수와 테스트 퀄리티의 범위 감소<br/>
    <b>limitation</b> : usability testing과 같이 자동화할 수 없는 테스트 존재, 환경이 변화하면 깨질 수 있고, automation이 더 비쌀 수 있음
    <h3>More types of testing</h3>
    Fault-based testing : look for common faults<br/>
    Scenario-based testing : based on user stories<br/>
    Model-based testing : derive from model of the software<br/>
    Random testing : 랜덤한 인풋 -> 크래시가 나는지, 오라클에 맞는지
    
    <h2>JUnit</h2>
    Open source Java testing framework : automated test support <br/>
    For unit and integration testing, not system testing <br/>
    Each test is embedded into one test method (@Test) <br/>
    Test method : checks a condition(assertion)<br/>
    org.junit.Assert.*, assertTrue(boolean), assertTrue(String, boolean), assertEquals(expected result Object, test oracle Object) <br/>
    @Before와 @After로 테스트의 state를 겹치게 하지 않고 돌릴 수 있음
    
    <h2>Test Coverage</h2>
    Test criteria : collection of Test requirements rule <br/>
    Define model -> find test criteria for model <br/>
    Test case = traceable repeatable simple
    
    <h3>Equivalence partitioning</h3> : input 범위를 균등하게 나눠서 넣음 <br/>
    Conbinatorial Testing : choose effective subsets from partitions <br/>
    structural coverage: method, statement, branch, condition
    
    <h2 id="Lecture4">eXtreme Programming</h2>
    Main idea : 문서화를 너무 많이 하지 말 것 : 코드와 테스트로 알 수 있게 <br/>
    feature를 하나씩 구현, 코드를 자주 릴리즈, 고객과 가까이 일하고 팀 멤버와 자주 소통 <br/>
    <h3>Key practice</h3>
    <b>Planning game</b> for requirements and user stories<br/>
    <b>Test-driven development</b> for design and testing<br/>
    <b>Refactoring</b> for design and implementation<br/>
    <b>Pair programming</b> for development<br/>
    <b>Continuous integration</b> for integration<br/><br/>
    <img src="image/sd2.PNG" alt="">
    <h2>Pair Programming</h2>
    Driver : types or writes (코딩 및 디버깅, 테스팅 등)<br/>
    Navigator : observes(오류가 있나 관찰) <br/>
    30분마다 역할을 바꿈 <br/>
    둘 다 집중할 수 있고, 효율이 좋음
    
    <h2>User stories</h2>
    a feature <b>customers want</b> in the software<br/>
    <b>story points</b> : unit of measure the overall size of a user story, feature 등등
    
    <h2>How to plan</h2>
    Make a list, decide when you will do, what you need<br/>
    
    Refactoring : recover simplicity back <br/>
    <br/>
    Write test first, and write code
    
    <h2>XP Rules</h2>
    Make it work/right/fast, Refactoring amkes design<br/>
    XP는 문서화를 거의 하지 않고 코드로서 모든 것을 이해해야 하기 때문에 코드 자체가 이해하기 쉬워야 함
    
    <h2>Code Smells</h2>
    <i>. . . certain structures in the code that suggest (sometimes they scream for) the possibility of refactoring.</i> <b>– M. Fowler</b><br/>
    <i>. . . symptom[s] in the source code of a program that possibly indicate a deeper problem. . . . usually not bugs ... not technically incorrect and don’t currently prevent the program from functioning. Instead, they indicate weaknesses in design that may be slowing down development or increasing the risk of bugs or failures in the future.</i>  <b>–Wikipedia</b>
</body>
</html>